#ifdef PLATFORM_NATIVE

#include <drivers/native/SDL2_Drawer.h>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <cstdarg>
#include <cstdio>

namespace pr32 = pixelroot32;

pr32::drivers::native::SDL2_Drawer::SDL2_Drawer()
    : window(nullptr)
    , renderer(nullptr)
    , texture(nullptr)
    , pixels(nullptr)
    , cursorX(0)
    , cursorY(0)
    , textColor(0xFFFF)
    , textSize(1)
    , rotation(0)
{
}

pr32::drivers::native::SDL2_Drawer::~SDL2_Drawer() {
    if (texture) SDL_DestroyTexture(texture);
    if (renderer) SDL_DestroyRenderer(renderer);
    if (window) SDL_DestroyWindow(window);
    if (pixels) delete[] pixels;
    SDL_Quit();
}

void pr32::drivers::native::SDL2_Drawer::init() {
    SDL_Init(SDL_INIT_VIDEO);

    int scale = 2;
    window = SDL_CreateWindow(
        "ESP32 Game Engine Mock",
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        displayWidth * scale,
        displayHeight * scale,
        SDL_WINDOW_SHOWN
    );

    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    SDL_RenderSetLogicalSize(renderer, displayWidth, displayHeight);

    texture = SDL_CreateTexture(
        renderer,
        SDL_PIXELFORMAT_RGB565,
        SDL_TEXTUREACCESS_STREAMING,
        displayWidth,
        displayHeight
    );

    pixels = new uint16_t[displayWidth * displayHeight];
    memset(pixels, 0, displayWidth * displayHeight * sizeof(uint16_t));
}

void pr32::drivers::native::SDL2_Drawer::setRotation(uint8_t rot) {
    rotation = rot;
}

void pr32::drivers::native::SDL2_Drawer::clearBuffer() {
    // LIMPIAR FRAMEBUFFER (no renderer)
    memset(pixels, 0, displayWidth * displayHeight * sizeof(uint16_t));
}

void pr32::drivers::native::SDL2_Drawer::sendBuffer() {
    updateTexture();

    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    SDL_RenderCopy(renderer, texture, nullptr, nullptr);
    SDL_RenderPresent(renderer);
}

// ---------- TEXTO (AHORA VA AL FRAMEBUFFER) ----------

static const uint8_t font5x7[][7] = {
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Space (32)
        {0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04}, // !
        {0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00}, // "
        {0x0A, 0x0A, 0x1F, 0x0A, 0x1F, 0x0A, 0x0A}, // #
        {0x04, 0x0F, 0x14, 0x0E, 0x05, 0x1E, 0x04}, // $
        {0x18, 0x19, 0x02, 0x04, 0x08, 0x13, 0x03}, // %
        {0x0C, 0x12, 0x14, 0x08, 0x15, 0x12, 0x0D}, // &
        {0x04, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00}, // '
        {0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02}, // (
        {0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08}, // )
        {0x00, 0x04, 0x15, 0x0E, 0x15, 0x04, 0x00}, // *
        {0x00, 0x04, 0x04, 0x1F, 0x04, 0x04, 0x00}, // +
        {0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x08}, // ,
        {0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00}, // -
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C}, // .
        {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00}, // /
        {0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E}, // 0
        {0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E}, // 1
        {0x0E, 0x11, 0x01, 0x02, 0x04, 0x08, 0x1F}, // 2
        {0x0E, 0x11, 0x01, 0x06, 0x01, 0x11, 0x0E}, // 3
        {0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02}, // 4
        {0x1F, 0x10, 0x10, 0x1E, 0x01, 0x01, 0x1E}, // 5
        {0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x0E}, // 6
        {0x1F, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08}, // 7
        {0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E}, // 8
        {0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C}, // 9
        {0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x0C, 0x00}, // :
        {0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x04, 0x08}, // ;
        {0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02}, // <
        {0x00, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x00}, // =
        {0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08}, // >
        {0x0E, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04}, // ?
        {0x0E, 0x11, 0x17, 0x15, 0x17, 0x10, 0x0F}, // @
        {0x04, 0x0A, 0x11, 0x11, 0x1F, 0x11, 0x11}, // A
        {0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E}, // B
        {0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E}, // C
        {0x1C, 0x12, 0x11, 0x11, 0x11, 0x12, 0x1C}, // D
        {0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F}, // E
        {0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10}, // F
        {0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0F}, // G
        {0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11}, // H
        {0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E}, // I
        {0x07, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0C}, // J
        {0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11}, // K
        {0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F}, // L
        {0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11}, // M
        {0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11}, // N
        {0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E}, // O
        {0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10}, // P
        {0x0E, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0D}, // Q
        {0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11}, // R
        {0x0F, 0x10, 0x10, 0x0E, 0x01, 0x01, 0x1E}, // S
        {0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04}, // T
        {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E}, // U
        {0x11, 0x11, 0x11, 0x11, 0x11, 0x0A, 0x04}, // V
        {0x11, 0x11, 0x11, 0x15, 0x15, 0x1B, 0x11}, // W
        {0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11}, // X
        {0x11, 0x11, 0x0A, 0x04, 0x04, 0x04, 0x04}, // Y
        {0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F}, // Z
        {0x0E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0E}, // [
        {0x00, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00}, // backslash
        {0x0E, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0E}, // ]
        {0x04, 0x0A, 0x11, 0x00, 0x00, 0x00, 0x00}, // ^
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F}, // _
        {0x08, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00}, // `
        {0x00, 0x00, 0x0E, 0x01, 0x0F, 0x11, 0x0F}, // a
        {0x10, 0x10, 0x1E, 0x11, 0x11, 0x11, 0x1E}, // b
        {0x00, 0x00, 0x0F, 0x10, 0x10, 0x10, 0x0F}, // c
        {0x01, 0x01, 0x0F, 0x11, 0x11, 0x11, 0x0F}, // d
        {0x00, 0x00, 0x0E, 0x11, 0x1F, 0x10, 0x0E}, // e
        {0x06, 0x08, 0x1E, 0x08, 0x08, 0x08, 0x08}, // f
        {0x00, 0x0F, 0x11, 0x11, 0x0F, 0x01, 0x0E}, // g
        {0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x11}, // h
        {0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x0E}, // i
        {0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0C}, // j
        {0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12}, // k
        {0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E}, // l
        {0x00, 0x00, 0x1A, 0x15, 0x15, 0x11, 0x11}, // m
        {0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11}, // n
        {0x00, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x0E}, // o
        {0x00, 0x00, 0x1E, 0x11, 0x11, 0x1E, 0x10}, // p
        {0x00, 0x00, 0x0F, 0x11, 0x11, 0x0F, 0x01}, // q
        {0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10}, // r
        {0x00, 0x00, 0x0F, 0x10, 0x0E, 0x01, 0x1E}, // s
        {0x08, 0x08, 0x1E, 0x08, 0x08, 0x08, 0x07}, // t
        {0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x0F}, // u
        {0x00, 0x00, 0x11, 0x11, 0x11, 0x0A, 0x04}, // v
        {0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0A}, // w
        {0x00, 0x00, 0x11, 0x0A, 0x04, 0x0A, 0x11}, // x
        {0x00, 0x00, 0x11, 0x11, 0x0F, 0x01, 0x0E}, // y
        {0x00, 0x00, 0x1F, 0x02, 0x04, 0x08, 0x1F}, // z
        {0x02, 0x04, 0x04, 0x08, 0x04, 0x04, 0x02}, // {
        {0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04}, // |
        {0x08, 0x04, 0x04, 0x02, 0x04, 0x04, 0x08}, // }
        {0x00, 0x00, 0x08, 0x15, 0x02, 0x00, 0x00}, // ~
    };

void pr32::drivers::native::SDL2_Drawer::drawText(const char* text, int16_t x, int16_t y, uint16_t color, uint8_t size) {
    setTextColor(color);
    setTextSize(size);
    setCursor(x, y);
    print(text, font5x7);
}

void pr32::drivers::native::SDL2_Drawer::drawTextCentered(const char* text, int16_t y, uint16_t color, uint8_t size) {
    setTextColor(color);
    setTextSize(size);
    int16_t textWidth = this->textWidth(text);
    int16_t x = (displayWidth - textWidth) / 2;
    setCursor(x, y);
    print(text, font5x7);
}

// ---------- PRIMITIVAS ----------

void pr32::drivers::native::SDL2_Drawer::drawFilledCircle(int x, int y, int r, uint16_t color) {
    int f = 1 - r;
    int ddF_x = 1;
    int ddF_y = -2 * r;
    int px = 0;
    int py = r;

    // l√≠nea central
    drawHLine(x - r, y, 2 * r + 1, color);

    while (px < py) {
        if (f >= 0) {
            py--;
            ddF_y += 2;
            f += ddF_y;
        }
        px++;
        ddF_x += 2;
        f += ddF_x;

        // Parte superior e inferior
        drawHLine(x - px, y + py, 2 * px + 1, color);
        drawHLine(x - px, y - py, 2 * px + 1, color);

        // Parte izquierda y derecha
        drawHLine(x - py, y + px, 2 * py + 1, color);
        drawHLine(x - py, y - px, 2 * py + 1, color);
    }
}

void pr32::drivers::native::SDL2_Drawer::drawCircle(int x, int y, int r, uint16_t color) {
    int f = 1 - r;
    int ddF_x = 1;
    int ddF_y = -2 * r;
    int px = 0;
    int py = r;

    setPixel(x, y + r, color);
    setPixel(x, y - r, color);
    setPixel(x + r, y, color);
    setPixel(x - r, y, color);

    while (px < py) {
        if (f >= 0) {
            py--;
            ddF_y += 2;
            f += ddF_y;
        }
        px++;
        ddF_x += 2;
        f += ddF_x;

        setPixel(x + px, y + py, color);
        setPixel(x - px, y + py, color);
        setPixel(x + px, y - py, color);
        setPixel(x - px, y - py, color);
        setPixel(x + py, y + px, color);
        setPixel(x - py, y + px, color);
        setPixel(x + py, y - px, color);
        setPixel(x - py, y - px, color);
    }
}

void pr32::drivers::native::SDL2_Drawer::drawFilledRectangle(int x, int y, int w, int h, uint16_t color) {
    for (int j = y; j < y + h; j++)
        for (int i = x; i < x + w; i++)
            setPixel(i, j, color);
}

void pr32::drivers::native::SDL2_Drawer::updateTexture() {
    SDL_UpdateTexture(texture, nullptr, pixels, displayWidth * sizeof(uint16_t));
}

bool pr32::drivers::native::SDL2_Drawer::processEvents() {
    SDL_Event e;
    while (SDL_PollEvent(&e)) {
        if (e.type == SDL_QUIT) return false;
    }
    return true;
}

void pr32::drivers::native::SDL2_Drawer::drawRectangle(int x, int y, int width, int height, uint16_t color) {
    drawLine(x, y, x + width - 1, y, color);
    drawLine(x + width - 1, y, x + width - 1, y + height - 1, color);
    drawLine(x + width - 1, y + height - 1, x, y + height - 1, color);
    drawLine(x, y + height - 1, x, y, color);
}

void pr32::drivers::native::SDL2_Drawer::drawLine(int x1, int y1, int x2, int y2, uint16_t color) {
    int dx = abs(x2 - x1);
    int dy = -abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx + dy;

    while (true) {
        setPixel(x1, y1, color);
        if (x1 == x2 && y1 == y2) break;
        int e2 = 2 * err;
        if (e2 >= dy) { err += dy; x1 += sx; }
        if (e2 <= dx) { err += dx; y1 += sy; }
    }
}

void pr32::drivers::native::SDL2_Drawer::drawBitmap(int x, int y, int w, int h, const uint8_t* bitmap, uint16_t color) {
    if (!bitmap) return;
    int bytesPerRow = (w + 7) / 8;

    for (int j = 0; j < h; j++) {
        for (int i = 0; i < w; i++) {
            int byteIndex = j * bytesPerRow + (i >> 3);
            if (bitmap[byteIndex] & (1 << (i & 7))) {
                setPixel(x + i, y + j, color);
            }
        }
    }
}

void pr32::drivers::native::SDL2_Drawer::drawPixel(int x, int y, uint16_t color) {
    setPixel(x, y, color);
}

void pr32::drivers::native::SDL2_Drawer::setTextColor(uint16_t color) {
    textColor = color;
}

void pr32::drivers::native::SDL2_Drawer::setTextSize(uint8_t size) {
    textSize = size;
}

void pr32::drivers::native::SDL2_Drawer::setCursor(int16_t x, int16_t y) {
    cursorX = x;
    cursorY = y;
}

uint16_t pr32::drivers::native::SDL2_Drawer::color565(uint8_t r, uint8_t g, uint8_t b) {
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}

void pr32::drivers::native::SDL2_Drawer::setDisplaySize(int w, int h) {
    displayWidth = w;
    displayHeight = h;
}

void pr32::drivers::native::SDL2_Drawer::present() {
    sendBuffer(); // wrapper por compatibilidad
}

#endif // PLATFORM_NATIVE
